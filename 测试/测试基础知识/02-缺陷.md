## 一、什么是缺陷？

### 1、软件测试的流程/个人计划

1. 需求评审
2. 测试计划
3. 用例设计
4. 用例执行
5. **缺陷管理 （提交、验证、关闭）**
6. 测试报告

### 2、缺陷的定义

软件在使用过程中存在的任何问题都叫软件的缺陷。 **注意，是任何问题，不符合用户需求的都是缺陷！**

### 3、缺陷的类型

1. 遗漏 **未实现需求的所有功能**
2. 错误 **出现了不应该出现的错误或者不符合需求的功能**
3. 冗余 **功能大大超出需求范围**
4. 隐性需求 **有些功能需求中未指明，但是得实现，如：行业标准、规范，用户可能会需要的功能，潜在需求（尽善尽美）**
5. 不易使用 **站在客户、普通人、受众人群的角度，是否简单上手易用呢？是否响应快速呢？**

### **4、常见缺陷产生的原因**

1. 需求阶段

1. **需求不清晰**
2. **需求变更**

3. 设计阶段 **设计文档有错误和缺陷**
4. 编码阶段

1. **新引入问题，修复BUG时带来新的BUG**
2. **代码出现错误**
3. **架构缺陷**
4. **数据库/数据有误**

6. 运行阶段

1. **软硬件系统本身故障导致软件缺陷**
2. **因版本覆盖升级导致的 Bug**
3. **客户配置不正确，或者未导入正确配置产生的 Bug**
4. **更加符合受众人群使用的建议**

### **5、缺陷的跟踪流程/生命周期**

![](https://pic1.zhimg.com/80/v2-2a45d88931979feb2b6a50c9d18ea3d8_1440w.webp)

转自https://blog.csdn.net/m0_51393235/article/details/117405343

发现BUG-->提交BUG-->指派BUG-->研发确认BUG-->研发去修复BUG-->回归验证BUG-->是否通过验证-->关闭BUG

- **特殊情况**

1. 不是每个缺陷都能及时得到修正，可能由于时间关系或技术限制，某些缺陷不得不延迟到下一个版本中去修正
2. 有些缺陷描述不清楚，开发人员看不懂或不能再现，将缺陷打回，让测试人员补充信息
3. 有些缺陷得到了开发人员处理，认为已得到修正，测试人员验证之后，缺陷依旧存在，没有得到彻底的处理。这样，测试人员不得不重新打开这个缺陷，交给开发人员的处理

### 6、需求与实现不一致

有时候会出现功能实现的逻辑上可能和需求文档不一样，但是**最终还是实现了该功能**或是**额外实现了某功能**，对于这种情况，**应该与产品和研发一起进行确认**：研发为什么要做出一个跟需求不匹配的东西？是否会对其他功能造成影响？

**进过探讨后再决定，是按照bug处理提交缺陷让研发更改，还是更改需求文档。**

**结果：还是得让需求和功能实现统一！**

## 二、缺陷的提交

### 1、提交注意事项

1. **可复现**：发现缺陷后，首先应该**确定Bug可复现、确定是Bug**。
2. **唯一性**：缺陷提交时，**要检查缺陷是否已存在。**
3. **规范性**：5C原则

1. correct **准确**
2. concise **简洁**
3. consistent **一致**
4. clear **清晰**
5. complete **完整**

5. **不做评价**：在软件缺陷描述**不要带有个人观点**，对开发人员进行评价。软件缺陷报告是针对产品、问题本身，将事实或现象客观地描述出来就可以，不需要任何评价或议论
6. **特定条件：**许多软件功能在**通常情况下没有问题，而是在某种特定条件下会存在缺陷**，例如网络繁忙时。所以软件缺陷描述不要忽视这些看似细节的但又必要的特定条件

### **2、缺陷的核心要素**

任何项目的缺陷提交，以下要素都是必备的

1. 标题 **简短精炼的描述**
2. 预置条件 **软硬件、网络环境**
3. 复现步骤 **怎样操作会导致该缺陷**
4. 预期结果 **预期结果或是更好的结果**
5. 实际结果 **报错/未执行/不符合需求**
6. 附件备注 **照片/截图、日志信息等证据**
7. 缺陷等级* **（修复优先级/严重等级）**

### **3、缺陷报告的主要内容**

除**核心要素**以外，以下内容也常出现在缺陷报告中

1. 缺陷ID **缺陷的唯一性标志**
2. 提出人 **谁提出的**
3. 指派人/责任人 **由谁来解决**
4. 状态*
5. 提出时间 /出现缺陷的软件版本
6. 计划解决时间 /修复缺陷的软件版本
7. 解决时间 **利于回归测试**
8. 验证人
9. 验证结果
10. 统计缺陷

### 4、缺陷等级

缺陷等级的定级和用例的优先级/重要程度相**类似**

![](https://pic1.zhimg.com/80/v2-17c6e19364dd4b1e459c89c615196ca0_1440w.webp)

但很多情况下，**修复优先级≠严重等级**

通常来说，**优先级的定义依赖于严重程度**

**严重程度（Severity）**是由**测试人员（你）**衡量和定级的

**优先级（Priority）**是由**开发人员、项目组长**衡量和定级的，并且**会随着项目更新、实际情况而改变**

- **特殊情况**

1. 从客户角度看，缺陷不是很严重，但可能影响下面测试的执行，这时缺陷严重性低，但优先级高，需要尽快修正
2. 有些缺陷比较严重，但由于技术的限制或第三方产品的限制，暂时没法修正，其优先级就会低。

### **5、状态**

1. New：缺陷的初始状态
2. Open：开发人员开始修改缺陷
3. Fixed：开发人员修改完毕
4. Closed：回归测试通过，关闭缺陷
5. Reopen：回归测试失败，重新打开

### 6、缺陷标题/复现步骤

大多情况下，缺陷报告会将这两个结合，以追求缺陷报告的高效率

**格式：测试步骤和数据 + 执行结果 （+ 预期/需求）**

![](https://pic1.zhimg.com/80/v2-6a68b94f0e8718136882b61dedf90f4c_1440w.webp)

参考格式

## 三、回归测试

### 1、回归测试的定义

是指修改了旧代码后，重新测试以确认修改**没有引入新的错误或导致其他代码产生错误**。

### 2、回归测试的场景

1. **开发修改完bug之后**：

1. 将之前发现bug的用例再次执行一遍，已验证此问题已经修复，然后关闭对应的bug单，写明必要备注
2. 验证其他和此bug有依赖关系的场景用例是否正常

3. **迭代上线前**：

1. 范围：本次迭代全部场景
2. 方法：抽取其中部分用例做为回归测试用例
3. 执行：再次执行抽取的测试用例，记录结果

5. **底层代码的修改：**

1. 某次更新涉及到了最底层的代码、参数
